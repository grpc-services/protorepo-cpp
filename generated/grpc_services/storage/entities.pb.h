// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: grpc_services/storage/entities.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_grpc_5fservices_2fstorage_2fentities_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_grpc_5fservices_2fstorage_2fentities_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "grpc_services/common/Timestamp.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_grpc_5fservices_2fstorage_2fentities_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_grpc_5fservices_2fstorage_2fentities_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_grpc_5fservices_2fstorage_2fentities_2eproto;
namespace grpc_services {
namespace storage {
class AudioFacet;
struct AudioFacetDefaultTypeInternal;
extern AudioFacetDefaultTypeInternal _AudioFacet_default_instance_;
class Drive;
struct DriveDefaultTypeInternal;
extern DriveDefaultTypeInternal _Drive_default_instance_;
class FileFacet;
struct FileFacetDefaultTypeInternal;
extern FileFacetDefaultTypeInternal _FileFacet_default_instance_;
class FolderFacet;
struct FolderFacetDefaultTypeInternal;
extern FolderFacetDefaultTypeInternal _FolderFacet_default_instance_;
class Hashes;
struct HashesDefaultTypeInternal;
extern HashesDefaultTypeInternal _Hashes_default_instance_;
class Item;
struct ItemDefaultTypeInternal;
extern ItemDefaultTypeInternal _Item_default_instance_;
class ItemContentUpdatedEvent;
struct ItemContentUpdatedEventDefaultTypeInternal;
extern ItemContentUpdatedEventDefaultTypeInternal _ItemContentUpdatedEvent_default_instance_;
class ItemCreatedEvent;
struct ItemCreatedEventDefaultTypeInternal;
extern ItemCreatedEventDefaultTypeInternal _ItemCreatedEvent_default_instance_;
class ItemRemovedEvent;
struct ItemRemovedEventDefaultTypeInternal;
extern ItemRemovedEventDefaultTypeInternal _ItemRemovedEvent_default_instance_;
}  // namespace storage
}  // namespace grpc_services
PROTOBUF_NAMESPACE_OPEN
template<> ::grpc_services::storage::AudioFacet* Arena::CreateMaybeMessage<::grpc_services::storage::AudioFacet>(Arena*);
template<> ::grpc_services::storage::Drive* Arena::CreateMaybeMessage<::grpc_services::storage::Drive>(Arena*);
template<> ::grpc_services::storage::FileFacet* Arena::CreateMaybeMessage<::grpc_services::storage::FileFacet>(Arena*);
template<> ::grpc_services::storage::FolderFacet* Arena::CreateMaybeMessage<::grpc_services::storage::FolderFacet>(Arena*);
template<> ::grpc_services::storage::Hashes* Arena::CreateMaybeMessage<::grpc_services::storage::Hashes>(Arena*);
template<> ::grpc_services::storage::Item* Arena::CreateMaybeMessage<::grpc_services::storage::Item>(Arena*);
template<> ::grpc_services::storage::ItemContentUpdatedEvent* Arena::CreateMaybeMessage<::grpc_services::storage::ItemContentUpdatedEvent>(Arena*);
template<> ::grpc_services::storage::ItemCreatedEvent* Arena::CreateMaybeMessage<::grpc_services::storage::ItemCreatedEvent>(Arena*);
template<> ::grpc_services::storage::ItemRemovedEvent* Arena::CreateMaybeMessage<::grpc_services::storage::ItemRemovedEvent>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace grpc_services {
namespace storage {

enum ItemType : int {
  FILE = 0,
  FOLDER = 1,
  ItemType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ItemType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ItemType_IsValid(int value);
constexpr ItemType ItemType_MIN = FILE;
constexpr ItemType ItemType_MAX = FOLDER;
constexpr int ItemType_ARRAYSIZE = ItemType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ItemType_descriptor();
template<typename T>
inline const std::string& ItemType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ItemType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ItemType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ItemType_descriptor(), enum_t_value);
}
inline bool ItemType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ItemType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ItemType>(
    ItemType_descriptor(), name, value);
}
// ===================================================================

class Hashes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc_services.storage.Hashes) */ {
 public:
  inline Hashes() : Hashes(nullptr) {}
  ~Hashes() override;
  explicit constexpr Hashes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Hashes(const Hashes& from);
  Hashes(Hashes&& from) noexcept
    : Hashes() {
    *this = ::std::move(from);
  }

  inline Hashes& operator=(const Hashes& from) {
    CopyFrom(from);
    return *this;
  }
  inline Hashes& operator=(Hashes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Hashes& default_instance() {
    return *internal_default_instance();
  }
  static inline const Hashes* internal_default_instance() {
    return reinterpret_cast<const Hashes*>(
               &_Hashes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Hashes& a, Hashes& b) {
    a.Swap(&b);
  }
  inline void Swap(Hashes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Hashes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Hashes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Hashes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Hashes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Hashes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Hashes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc_services.storage.Hashes";
  }
  protected:
  explicit Hashes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCrc32FieldNumber = 1,
    kSha1FieldNumber = 2,
    kMd5FieldNumber = 3,
    kSha512FieldNumber = 4,
  };
  // string crc32 = 1;
  void clear_crc32();
  const std::string& crc32() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_crc32(ArgT0&& arg0, ArgT... args);
  std::string* mutable_crc32();
  PROTOBUF_NODISCARD std::string* release_crc32();
  void set_allocated_crc32(std::string* crc32);
  private:
  const std::string& _internal_crc32() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_crc32(const std::string& value);
  std::string* _internal_mutable_crc32();
  public:

  // string sha1 = 2;
  void clear_sha1();
  const std::string& sha1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sha1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sha1();
  PROTOBUF_NODISCARD std::string* release_sha1();
  void set_allocated_sha1(std::string* sha1);
  private:
  const std::string& _internal_sha1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sha1(const std::string& value);
  std::string* _internal_mutable_sha1();
  public:

  // string md5 = 3;
  void clear_md5();
  const std::string& md5() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_md5(ArgT0&& arg0, ArgT... args);
  std::string* mutable_md5();
  PROTOBUF_NODISCARD std::string* release_md5();
  void set_allocated_md5(std::string* md5);
  private:
  const std::string& _internal_md5() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_md5(const std::string& value);
  std::string* _internal_mutable_md5();
  public:

  // string sha512 = 4;
  void clear_sha512();
  const std::string& sha512() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sha512(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sha512();
  PROTOBUF_NODISCARD std::string* release_sha512();
  void set_allocated_sha512(std::string* sha512);
  private:
  const std::string& _internal_sha512() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sha512(const std::string& value);
  std::string* _internal_mutable_sha512();
  public:

  // @@protoc_insertion_point(class_scope:grpc_services.storage.Hashes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr crc32_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sha1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr md5_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sha512_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_grpc_5fservices_2fstorage_2fentities_2eproto;
};
// -------------------------------------------------------------------

class FolderFacet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc_services.storage.FolderFacet) */ {
 public:
  inline FolderFacet() : FolderFacet(nullptr) {}
  ~FolderFacet() override;
  explicit constexpr FolderFacet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FolderFacet(const FolderFacet& from);
  FolderFacet(FolderFacet&& from) noexcept
    : FolderFacet() {
    *this = ::std::move(from);
  }

  inline FolderFacet& operator=(const FolderFacet& from) {
    CopyFrom(from);
    return *this;
  }
  inline FolderFacet& operator=(FolderFacet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FolderFacet& default_instance() {
    return *internal_default_instance();
  }
  static inline const FolderFacet* internal_default_instance() {
    return reinterpret_cast<const FolderFacet*>(
               &_FolderFacet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FolderFacet& a, FolderFacet& b) {
    a.Swap(&b);
  }
  inline void Swap(FolderFacet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FolderFacet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FolderFacet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FolderFacet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FolderFacet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FolderFacet& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FolderFacet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc_services.storage.FolderFacet";
  }
  protected:
  explicit FolderFacet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumItemsFieldNumber = 1,
  };
  // uint64 num_items = 1;
  void clear_num_items();
  uint64_t num_items() const;
  void set_num_items(uint64_t value);
  private:
  uint64_t _internal_num_items() const;
  void _internal_set_num_items(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpc_services.storage.FolderFacet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t num_items_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_grpc_5fservices_2fstorage_2fentities_2eproto;
};
// -------------------------------------------------------------------

class FileFacet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc_services.storage.FileFacet) */ {
 public:
  inline FileFacet() : FileFacet(nullptr) {}
  ~FileFacet() override;
  explicit constexpr FileFacet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileFacet(const FileFacet& from);
  FileFacet(FileFacet&& from) noexcept
    : FileFacet() {
    *this = ::std::move(from);
  }

  inline FileFacet& operator=(const FileFacet& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileFacet& operator=(FileFacet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileFacet& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileFacet* internal_default_instance() {
    return reinterpret_cast<const FileFacet*>(
               &_FileFacet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FileFacet& a, FileFacet& b) {
    a.Swap(&b);
  }
  inline void Swap(FileFacet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileFacet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileFacet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileFacet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileFacet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FileFacet& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileFacet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc_services.storage.FileFacet";
  }
  protected:
  explicit FileFacet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMimeTypeFieldNumber = 2,
    kHashesFieldNumber = 1,
    kAudioFieldNumber = 3,
    kSizeFieldNumber = 4,
  };
  // string mime_type = 2;
  void clear_mime_type();
  const std::string& mime_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mime_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mime_type();
  PROTOBUF_NODISCARD std::string* release_mime_type();
  void set_allocated_mime_type(std::string* mime_type);
  private:
  const std::string& _internal_mime_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mime_type(const std::string& value);
  std::string* _internal_mutable_mime_type();
  public:

  // .grpc_services.storage.Hashes hashes = 1;
  bool has_hashes() const;
  private:
  bool _internal_has_hashes() const;
  public:
  void clear_hashes();
  const ::grpc_services::storage::Hashes& hashes() const;
  PROTOBUF_NODISCARD ::grpc_services::storage::Hashes* release_hashes();
  ::grpc_services::storage::Hashes* mutable_hashes();
  void set_allocated_hashes(::grpc_services::storage::Hashes* hashes);
  private:
  const ::grpc_services::storage::Hashes& _internal_hashes() const;
  ::grpc_services::storage::Hashes* _internal_mutable_hashes();
  public:
  void unsafe_arena_set_allocated_hashes(
      ::grpc_services::storage::Hashes* hashes);
  ::grpc_services::storage::Hashes* unsafe_arena_release_hashes();

  // .grpc_services.storage.AudioFacet audio = 3;
  bool has_audio() const;
  private:
  bool _internal_has_audio() const;
  public:
  void clear_audio();
  const ::grpc_services::storage::AudioFacet& audio() const;
  PROTOBUF_NODISCARD ::grpc_services::storage::AudioFacet* release_audio();
  ::grpc_services::storage::AudioFacet* mutable_audio();
  void set_allocated_audio(::grpc_services::storage::AudioFacet* audio);
  private:
  const ::grpc_services::storage::AudioFacet& _internal_audio() const;
  ::grpc_services::storage::AudioFacet* _internal_mutable_audio();
  public:
  void unsafe_arena_set_allocated_audio(
      ::grpc_services::storage::AudioFacet* audio);
  ::grpc_services::storage::AudioFacet* unsafe_arena_release_audio();

  // uint64 size = 4;
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpc_services.storage.FileFacet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mime_type_;
  ::grpc_services::storage::Hashes* hashes_;
  ::grpc_services::storage::AudioFacet* audio_;
  uint64_t size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_grpc_5fservices_2fstorage_2fentities_2eproto;
};
// -------------------------------------------------------------------

class AudioFacet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc_services.storage.AudioFacet) */ {
 public:
  inline AudioFacet() : AudioFacet(nullptr) {}
  ~AudioFacet() override;
  explicit constexpr AudioFacet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioFacet(const AudioFacet& from);
  AudioFacet(AudioFacet&& from) noexcept
    : AudioFacet() {
    *this = ::std::move(from);
  }

  inline AudioFacet& operator=(const AudioFacet& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioFacet& operator=(AudioFacet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioFacet& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioFacet* internal_default_instance() {
    return reinterpret_cast<const AudioFacet*>(
               &_AudioFacet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AudioFacet& a, AudioFacet& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioFacet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioFacet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioFacet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioFacet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AudioFacet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AudioFacet& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioFacet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc_services.storage.AudioFacet";
  }
  protected:
  explicit AudioFacet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBitrateFieldNumber = 1,
    kDurationFieldNumber = 2,
    kIsVbrFieldNumber = 3,
  };
  // uint64 bitrate = 1;
  void clear_bitrate();
  uint64_t bitrate() const;
  void set_bitrate(uint64_t value);
  private:
  uint64_t _internal_bitrate() const;
  void _internal_set_bitrate(uint64_t value);
  public:

  // uint64 duration = 2;
  void clear_duration();
  uint64_t duration() const;
  void set_duration(uint64_t value);
  private:
  uint64_t _internal_duration() const;
  void _internal_set_duration(uint64_t value);
  public:

  // bool is_vbr = 3;
  void clear_is_vbr();
  bool is_vbr() const;
  void set_is_vbr(bool value);
  private:
  bool _internal_is_vbr() const;
  void _internal_set_is_vbr(bool value);
  public:

  // @@protoc_insertion_point(class_scope:grpc_services.storage.AudioFacet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t bitrate_;
  uint64_t duration_;
  bool is_vbr_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_grpc_5fservices_2fstorage_2fentities_2eproto;
};
// -------------------------------------------------------------------

class Drive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc_services.storage.Drive) */ {
 public:
  inline Drive() : Drive(nullptr) {}
  ~Drive() override;
  explicit constexpr Drive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Drive(const Drive& from);
  Drive(Drive&& from) noexcept
    : Drive() {
    *this = ::std::move(from);
  }

  inline Drive& operator=(const Drive& from) {
    CopyFrom(from);
    return *this;
  }
  inline Drive& operator=(Drive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Drive& default_instance() {
    return *internal_default_instance();
  }
  static inline const Drive* internal_default_instance() {
    return reinterpret_cast<const Drive*>(
               &_Drive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Drive& a, Drive& b) {
    a.Swap(&b);
  }
  inline void Swap(Drive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Drive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Drive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Drive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Drive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Drive& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Drive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc_services.storage.Drive";
  }
  protected:
  explicit Drive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kCreatedTimeFieldNumber = 4,
    kLastModifiedFieldNumber = 5,
    kLastItemModifiedFieldNumber = 6,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .grpc_services.common.Timestamp created_time = 4;
  bool has_created_time() const;
  private:
  bool _internal_has_created_time() const;
  public:
  void clear_created_time();
  const ::grpc_services::common::Timestamp& created_time() const;
  PROTOBUF_NODISCARD ::grpc_services::common::Timestamp* release_created_time();
  ::grpc_services::common::Timestamp* mutable_created_time();
  void set_allocated_created_time(::grpc_services::common::Timestamp* created_time);
  private:
  const ::grpc_services::common::Timestamp& _internal_created_time() const;
  ::grpc_services::common::Timestamp* _internal_mutable_created_time();
  public:
  void unsafe_arena_set_allocated_created_time(
      ::grpc_services::common::Timestamp* created_time);
  ::grpc_services::common::Timestamp* unsafe_arena_release_created_time();

  // .grpc_services.common.Timestamp last_modified = 5;
  bool has_last_modified() const;
  private:
  bool _internal_has_last_modified() const;
  public:
  void clear_last_modified();
  const ::grpc_services::common::Timestamp& last_modified() const;
  PROTOBUF_NODISCARD ::grpc_services::common::Timestamp* release_last_modified();
  ::grpc_services::common::Timestamp* mutable_last_modified();
  void set_allocated_last_modified(::grpc_services::common::Timestamp* last_modified);
  private:
  const ::grpc_services::common::Timestamp& _internal_last_modified() const;
  ::grpc_services::common::Timestamp* _internal_mutable_last_modified();
  public:
  void unsafe_arena_set_allocated_last_modified(
      ::grpc_services::common::Timestamp* last_modified);
  ::grpc_services::common::Timestamp* unsafe_arena_release_last_modified();

  // .grpc_services.common.Timestamp last_item_modified = 6;
  bool has_last_item_modified() const;
  private:
  bool _internal_has_last_item_modified() const;
  public:
  void clear_last_item_modified();
  const ::grpc_services::common::Timestamp& last_item_modified() const;
  PROTOBUF_NODISCARD ::grpc_services::common::Timestamp* release_last_item_modified();
  ::grpc_services::common::Timestamp* mutable_last_item_modified();
  void set_allocated_last_item_modified(::grpc_services::common::Timestamp* last_item_modified);
  private:
  const ::grpc_services::common::Timestamp& _internal_last_item_modified() const;
  ::grpc_services::common::Timestamp* _internal_mutable_last_item_modified();
  public:
  void unsafe_arena_set_allocated_last_item_modified(
      ::grpc_services::common::Timestamp* last_item_modified);
  ::grpc_services::common::Timestamp* unsafe_arena_release_last_item_modified();

  // @@protoc_insertion_point(class_scope:grpc_services.storage.Drive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::grpc_services::common::Timestamp* created_time_;
  ::grpc_services::common::Timestamp* last_modified_;
  ::grpc_services::common::Timestamp* last_item_modified_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_grpc_5fservices_2fstorage_2fentities_2eproto;
};
// -------------------------------------------------------------------

class Item final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc_services.storage.Item) */ {
 public:
  inline Item() : Item(nullptr) {}
  ~Item() override;
  explicit constexpr Item(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Item(const Item& from);
  Item(Item&& from) noexcept
    : Item() {
    *this = ::std::move(from);
  }

  inline Item& operator=(const Item& from) {
    CopyFrom(from);
    return *this;
  }
  inline Item& operator=(Item&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Item& default_instance() {
    return *internal_default_instance();
  }
  enum TestTypeCase {
    kFile = 8,
    kFolder = 9,
    TEST_TYPE_NOT_SET = 0,
  };

  static inline const Item* internal_default_instance() {
    return reinterpret_cast<const Item*>(
               &_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Item& a, Item& b) {
    a.Swap(&b);
  }
  inline void Swap(Item* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Item* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Item* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Item>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Item& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Item& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Item* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc_services.storage.Item";
  }
  protected:
  explicit Item(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kParentIdFieldNumber = 6,
    kCreatedTimeFieldNumber = 4,
    kLastModifiedFieldNumber = 5,
    kTypeFieldNumber = 7,
    kFileFieldNumber = 8,
    kFolderFieldNumber = 9,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string parent_id = 6;
  void clear_parent_id();
  const std::string& parent_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent_id();
  PROTOBUF_NODISCARD std::string* release_parent_id();
  void set_allocated_parent_id(std::string* parent_id);
  private:
  const std::string& _internal_parent_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_id(const std::string& value);
  std::string* _internal_mutable_parent_id();
  public:

  // .grpc_services.common.Timestamp created_time = 4;
  bool has_created_time() const;
  private:
  bool _internal_has_created_time() const;
  public:
  void clear_created_time();
  const ::grpc_services::common::Timestamp& created_time() const;
  PROTOBUF_NODISCARD ::grpc_services::common::Timestamp* release_created_time();
  ::grpc_services::common::Timestamp* mutable_created_time();
  void set_allocated_created_time(::grpc_services::common::Timestamp* created_time);
  private:
  const ::grpc_services::common::Timestamp& _internal_created_time() const;
  ::grpc_services::common::Timestamp* _internal_mutable_created_time();
  public:
  void unsafe_arena_set_allocated_created_time(
      ::grpc_services::common::Timestamp* created_time);
  ::grpc_services::common::Timestamp* unsafe_arena_release_created_time();

  // .grpc_services.common.Timestamp last_modified = 5;
  bool has_last_modified() const;
  private:
  bool _internal_has_last_modified() const;
  public:
  void clear_last_modified();
  const ::grpc_services::common::Timestamp& last_modified() const;
  PROTOBUF_NODISCARD ::grpc_services::common::Timestamp* release_last_modified();
  ::grpc_services::common::Timestamp* mutable_last_modified();
  void set_allocated_last_modified(::grpc_services::common::Timestamp* last_modified);
  private:
  const ::grpc_services::common::Timestamp& _internal_last_modified() const;
  ::grpc_services::common::Timestamp* _internal_mutable_last_modified();
  public:
  void unsafe_arena_set_allocated_last_modified(
      ::grpc_services::common::Timestamp* last_modified);
  ::grpc_services::common::Timestamp* unsafe_arena_release_last_modified();

  // .grpc_services.storage.ItemType type = 7;
  void clear_type();
  ::grpc_services::storage::ItemType type() const;
  void set_type(::grpc_services::storage::ItemType value);
  private:
  ::grpc_services::storage::ItemType _internal_type() const;
  void _internal_set_type(::grpc_services::storage::ItemType value);
  public:

  // .grpc_services.storage.FileFacet file = 8;
  bool has_file() const;
  private:
  bool _internal_has_file() const;
  public:
  void clear_file();
  const ::grpc_services::storage::FileFacet& file() const;
  PROTOBUF_NODISCARD ::grpc_services::storage::FileFacet* release_file();
  ::grpc_services::storage::FileFacet* mutable_file();
  void set_allocated_file(::grpc_services::storage::FileFacet* file);
  private:
  const ::grpc_services::storage::FileFacet& _internal_file() const;
  ::grpc_services::storage::FileFacet* _internal_mutable_file();
  public:
  void unsafe_arena_set_allocated_file(
      ::grpc_services::storage::FileFacet* file);
  ::grpc_services::storage::FileFacet* unsafe_arena_release_file();

  // .grpc_services.storage.FolderFacet folder = 9;
  bool has_folder() const;
  private:
  bool _internal_has_folder() const;
  public:
  void clear_folder();
  const ::grpc_services::storage::FolderFacet& folder() const;
  PROTOBUF_NODISCARD ::grpc_services::storage::FolderFacet* release_folder();
  ::grpc_services::storage::FolderFacet* mutable_folder();
  void set_allocated_folder(::grpc_services::storage::FolderFacet* folder);
  private:
  const ::grpc_services::storage::FolderFacet& _internal_folder() const;
  ::grpc_services::storage::FolderFacet* _internal_mutable_folder();
  public:
  void unsafe_arena_set_allocated_folder(
      ::grpc_services::storage::FolderFacet* folder);
  ::grpc_services::storage::FolderFacet* unsafe_arena_release_folder();

  void clear_test_type();
  TestTypeCase test_type_case() const;
  // @@protoc_insertion_point(class_scope:grpc_services.storage.Item)
 private:
  class _Internal;
  void set_has_file();
  void set_has_folder();

  inline bool has_test_type() const;
  inline void clear_has_test_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_id_;
  ::grpc_services::common::Timestamp* created_time_;
  ::grpc_services::common::Timestamp* last_modified_;
  int type_;
  union TestTypeUnion {
    constexpr TestTypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::grpc_services::storage::FileFacet* file_;
    ::grpc_services::storage::FolderFacet* folder_;
  } test_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_grpc_5fservices_2fstorage_2fentities_2eproto;
};
// -------------------------------------------------------------------

class ItemCreatedEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc_services.storage.ItemCreatedEvent) */ {
 public:
  inline ItemCreatedEvent() : ItemCreatedEvent(nullptr) {}
  ~ItemCreatedEvent() override;
  explicit constexpr ItemCreatedEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemCreatedEvent(const ItemCreatedEvent& from);
  ItemCreatedEvent(ItemCreatedEvent&& from) noexcept
    : ItemCreatedEvent() {
    *this = ::std::move(from);
  }

  inline ItemCreatedEvent& operator=(const ItemCreatedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemCreatedEvent& operator=(ItemCreatedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemCreatedEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemCreatedEvent* internal_default_instance() {
    return reinterpret_cast<const ItemCreatedEvent*>(
               &_ItemCreatedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ItemCreatedEvent& a, ItemCreatedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemCreatedEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemCreatedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemCreatedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemCreatedEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItemCreatedEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ItemCreatedEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemCreatedEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc_services.storage.ItemCreatedEvent";
  }
  protected:
  explicit ItemCreatedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 1,
  };
  // .grpc_services.storage.Item item = 1;
  bool has_item() const;
  private:
  bool _internal_has_item() const;
  public:
  void clear_item();
  const ::grpc_services::storage::Item& item() const;
  PROTOBUF_NODISCARD ::grpc_services::storage::Item* release_item();
  ::grpc_services::storage::Item* mutable_item();
  void set_allocated_item(::grpc_services::storage::Item* item);
  private:
  const ::grpc_services::storage::Item& _internal_item() const;
  ::grpc_services::storage::Item* _internal_mutable_item();
  public:
  void unsafe_arena_set_allocated_item(
      ::grpc_services::storage::Item* item);
  ::grpc_services::storage::Item* unsafe_arena_release_item();

  // @@protoc_insertion_point(class_scope:grpc_services.storage.ItemCreatedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::grpc_services::storage::Item* item_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_grpc_5fservices_2fstorage_2fentities_2eproto;
};
// -------------------------------------------------------------------

class ItemRemovedEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc_services.storage.ItemRemovedEvent) */ {
 public:
  inline ItemRemovedEvent() : ItemRemovedEvent(nullptr) {}
  ~ItemRemovedEvent() override;
  explicit constexpr ItemRemovedEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemRemovedEvent(const ItemRemovedEvent& from);
  ItemRemovedEvent(ItemRemovedEvent&& from) noexcept
    : ItemRemovedEvent() {
    *this = ::std::move(from);
  }

  inline ItemRemovedEvent& operator=(const ItemRemovedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemRemovedEvent& operator=(ItemRemovedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemRemovedEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemRemovedEvent* internal_default_instance() {
    return reinterpret_cast<const ItemRemovedEvent*>(
               &_ItemRemovedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ItemRemovedEvent& a, ItemRemovedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemRemovedEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemRemovedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemRemovedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemRemovedEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItemRemovedEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ItemRemovedEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemRemovedEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc_services.storage.ItemRemovedEvent";
  }
  protected:
  explicit ItemRemovedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 1,
  };
  // .grpc_services.storage.Item item = 1;
  bool has_item() const;
  private:
  bool _internal_has_item() const;
  public:
  void clear_item();
  const ::grpc_services::storage::Item& item() const;
  PROTOBUF_NODISCARD ::grpc_services::storage::Item* release_item();
  ::grpc_services::storage::Item* mutable_item();
  void set_allocated_item(::grpc_services::storage::Item* item);
  private:
  const ::grpc_services::storage::Item& _internal_item() const;
  ::grpc_services::storage::Item* _internal_mutable_item();
  public:
  void unsafe_arena_set_allocated_item(
      ::grpc_services::storage::Item* item);
  ::grpc_services::storage::Item* unsafe_arena_release_item();

  // @@protoc_insertion_point(class_scope:grpc_services.storage.ItemRemovedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::grpc_services::storage::Item* item_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_grpc_5fservices_2fstorage_2fentities_2eproto;
};
// -------------------------------------------------------------------

class ItemContentUpdatedEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc_services.storage.ItemContentUpdatedEvent) */ {
 public:
  inline ItemContentUpdatedEvent() : ItemContentUpdatedEvent(nullptr) {}
  ~ItemContentUpdatedEvent() override;
  explicit constexpr ItemContentUpdatedEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemContentUpdatedEvent(const ItemContentUpdatedEvent& from);
  ItemContentUpdatedEvent(ItemContentUpdatedEvent&& from) noexcept
    : ItemContentUpdatedEvent() {
    *this = ::std::move(from);
  }

  inline ItemContentUpdatedEvent& operator=(const ItemContentUpdatedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemContentUpdatedEvent& operator=(ItemContentUpdatedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemContentUpdatedEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemContentUpdatedEvent* internal_default_instance() {
    return reinterpret_cast<const ItemContentUpdatedEvent*>(
               &_ItemContentUpdatedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ItemContentUpdatedEvent& a, ItemContentUpdatedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemContentUpdatedEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemContentUpdatedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemContentUpdatedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemContentUpdatedEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItemContentUpdatedEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ItemContentUpdatedEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemContentUpdatedEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc_services.storage.ItemContentUpdatedEvent";
  }
  protected:
  explicit ItemContentUpdatedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 1,
  };
  // .grpc_services.storage.Item item = 1;
  bool has_item() const;
  private:
  bool _internal_has_item() const;
  public:
  void clear_item();
  const ::grpc_services::storage::Item& item() const;
  PROTOBUF_NODISCARD ::grpc_services::storage::Item* release_item();
  ::grpc_services::storage::Item* mutable_item();
  void set_allocated_item(::grpc_services::storage::Item* item);
  private:
  const ::grpc_services::storage::Item& _internal_item() const;
  ::grpc_services::storage::Item* _internal_mutable_item();
  public:
  void unsafe_arena_set_allocated_item(
      ::grpc_services::storage::Item* item);
  ::grpc_services::storage::Item* unsafe_arena_release_item();

  // @@protoc_insertion_point(class_scope:grpc_services.storage.ItemContentUpdatedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::grpc_services::storage::Item* item_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_grpc_5fservices_2fstorage_2fentities_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Hashes

// string crc32 = 1;
inline void Hashes::clear_crc32() {
  crc32_.ClearToEmpty();
}
inline const std::string& Hashes::crc32() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.Hashes.crc32)
  return _internal_crc32();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Hashes::set_crc32(ArgT0&& arg0, ArgT... args) {
 
 crc32_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc_services.storage.Hashes.crc32)
}
inline std::string* Hashes::mutable_crc32() {
  std::string* _s = _internal_mutable_crc32();
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.Hashes.crc32)
  return _s;
}
inline const std::string& Hashes::_internal_crc32() const {
  return crc32_.Get();
}
inline void Hashes::_internal_set_crc32(const std::string& value) {
  
  crc32_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Hashes::_internal_mutable_crc32() {
  
  return crc32_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Hashes::release_crc32() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.Hashes.crc32)
  return crc32_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Hashes::set_allocated_crc32(std::string* crc32) {
  if (crc32 != nullptr) {
    
  } else {
    
  }
  crc32_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), crc32,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (crc32_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    crc32_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc_services.storage.Hashes.crc32)
}

// string sha1 = 2;
inline void Hashes::clear_sha1() {
  sha1_.ClearToEmpty();
}
inline const std::string& Hashes::sha1() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.Hashes.sha1)
  return _internal_sha1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Hashes::set_sha1(ArgT0&& arg0, ArgT... args) {
 
 sha1_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc_services.storage.Hashes.sha1)
}
inline std::string* Hashes::mutable_sha1() {
  std::string* _s = _internal_mutable_sha1();
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.Hashes.sha1)
  return _s;
}
inline const std::string& Hashes::_internal_sha1() const {
  return sha1_.Get();
}
inline void Hashes::_internal_set_sha1(const std::string& value) {
  
  sha1_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Hashes::_internal_mutable_sha1() {
  
  return sha1_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Hashes::release_sha1() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.Hashes.sha1)
  return sha1_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Hashes::set_allocated_sha1(std::string* sha1) {
  if (sha1 != nullptr) {
    
  } else {
    
  }
  sha1_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sha1,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sha1_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sha1_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc_services.storage.Hashes.sha1)
}

// string md5 = 3;
inline void Hashes::clear_md5() {
  md5_.ClearToEmpty();
}
inline const std::string& Hashes::md5() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.Hashes.md5)
  return _internal_md5();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Hashes::set_md5(ArgT0&& arg0, ArgT... args) {
 
 md5_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc_services.storage.Hashes.md5)
}
inline std::string* Hashes::mutable_md5() {
  std::string* _s = _internal_mutable_md5();
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.Hashes.md5)
  return _s;
}
inline const std::string& Hashes::_internal_md5() const {
  return md5_.Get();
}
inline void Hashes::_internal_set_md5(const std::string& value) {
  
  md5_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Hashes::_internal_mutable_md5() {
  
  return md5_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Hashes::release_md5() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.Hashes.md5)
  return md5_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Hashes::set_allocated_md5(std::string* md5) {
  if (md5 != nullptr) {
    
  } else {
    
  }
  md5_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), md5,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (md5_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    md5_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc_services.storage.Hashes.md5)
}

// string sha512 = 4;
inline void Hashes::clear_sha512() {
  sha512_.ClearToEmpty();
}
inline const std::string& Hashes::sha512() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.Hashes.sha512)
  return _internal_sha512();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Hashes::set_sha512(ArgT0&& arg0, ArgT... args) {
 
 sha512_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc_services.storage.Hashes.sha512)
}
inline std::string* Hashes::mutable_sha512() {
  std::string* _s = _internal_mutable_sha512();
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.Hashes.sha512)
  return _s;
}
inline const std::string& Hashes::_internal_sha512() const {
  return sha512_.Get();
}
inline void Hashes::_internal_set_sha512(const std::string& value) {
  
  sha512_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Hashes::_internal_mutable_sha512() {
  
  return sha512_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Hashes::release_sha512() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.Hashes.sha512)
  return sha512_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Hashes::set_allocated_sha512(std::string* sha512) {
  if (sha512 != nullptr) {
    
  } else {
    
  }
  sha512_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sha512,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sha512_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sha512_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc_services.storage.Hashes.sha512)
}

// -------------------------------------------------------------------

// FolderFacet

// uint64 num_items = 1;
inline void FolderFacet::clear_num_items() {
  num_items_ = uint64_t{0u};
}
inline uint64_t FolderFacet::_internal_num_items() const {
  return num_items_;
}
inline uint64_t FolderFacet::num_items() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.FolderFacet.num_items)
  return _internal_num_items();
}
inline void FolderFacet::_internal_set_num_items(uint64_t value) {
  
  num_items_ = value;
}
inline void FolderFacet::set_num_items(uint64_t value) {
  _internal_set_num_items(value);
  // @@protoc_insertion_point(field_set:grpc_services.storage.FolderFacet.num_items)
}

// -------------------------------------------------------------------

// FileFacet

// .grpc_services.storage.Hashes hashes = 1;
inline bool FileFacet::_internal_has_hashes() const {
  return this != internal_default_instance() && hashes_ != nullptr;
}
inline bool FileFacet::has_hashes() const {
  return _internal_has_hashes();
}
inline void FileFacet::clear_hashes() {
  if (GetArenaForAllocation() == nullptr && hashes_ != nullptr) {
    delete hashes_;
  }
  hashes_ = nullptr;
}
inline const ::grpc_services::storage::Hashes& FileFacet::_internal_hashes() const {
  const ::grpc_services::storage::Hashes* p = hashes_;
  return p != nullptr ? *p : reinterpret_cast<const ::grpc_services::storage::Hashes&>(
      ::grpc_services::storage::_Hashes_default_instance_);
}
inline const ::grpc_services::storage::Hashes& FileFacet::hashes() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.FileFacet.hashes)
  return _internal_hashes();
}
inline void FileFacet::unsafe_arena_set_allocated_hashes(
    ::grpc_services::storage::Hashes* hashes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hashes_);
  }
  hashes_ = hashes;
  if (hashes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc_services.storage.FileFacet.hashes)
}
inline ::grpc_services::storage::Hashes* FileFacet::release_hashes() {
  
  ::grpc_services::storage::Hashes* temp = hashes_;
  hashes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::grpc_services::storage::Hashes* FileFacet::unsafe_arena_release_hashes() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.FileFacet.hashes)
  
  ::grpc_services::storage::Hashes* temp = hashes_;
  hashes_ = nullptr;
  return temp;
}
inline ::grpc_services::storage::Hashes* FileFacet::_internal_mutable_hashes() {
  
  if (hashes_ == nullptr) {
    auto* p = CreateMaybeMessage<::grpc_services::storage::Hashes>(GetArenaForAllocation());
    hashes_ = p;
  }
  return hashes_;
}
inline ::grpc_services::storage::Hashes* FileFacet::mutable_hashes() {
  ::grpc_services::storage::Hashes* _msg = _internal_mutable_hashes();
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.FileFacet.hashes)
  return _msg;
}
inline void FileFacet::set_allocated_hashes(::grpc_services::storage::Hashes* hashes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete hashes_;
  }
  if (hashes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::grpc_services::storage::Hashes>::GetOwningArena(hashes);
    if (message_arena != submessage_arena) {
      hashes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hashes, submessage_arena);
    }
    
  } else {
    
  }
  hashes_ = hashes;
  // @@protoc_insertion_point(field_set_allocated:grpc_services.storage.FileFacet.hashes)
}

// string mime_type = 2;
inline void FileFacet::clear_mime_type() {
  mime_type_.ClearToEmpty();
}
inline const std::string& FileFacet::mime_type() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.FileFacet.mime_type)
  return _internal_mime_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileFacet::set_mime_type(ArgT0&& arg0, ArgT... args) {
 
 mime_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc_services.storage.FileFacet.mime_type)
}
inline std::string* FileFacet::mutable_mime_type() {
  std::string* _s = _internal_mutable_mime_type();
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.FileFacet.mime_type)
  return _s;
}
inline const std::string& FileFacet::_internal_mime_type() const {
  return mime_type_.Get();
}
inline void FileFacet::_internal_set_mime_type(const std::string& value) {
  
  mime_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FileFacet::_internal_mutable_mime_type() {
  
  return mime_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FileFacet::release_mime_type() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.FileFacet.mime_type)
  return mime_type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FileFacet::set_allocated_mime_type(std::string* mime_type) {
  if (mime_type != nullptr) {
    
  } else {
    
  }
  mime_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mime_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mime_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    mime_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc_services.storage.FileFacet.mime_type)
}

// .grpc_services.storage.AudioFacet audio = 3;
inline bool FileFacet::_internal_has_audio() const {
  return this != internal_default_instance() && audio_ != nullptr;
}
inline bool FileFacet::has_audio() const {
  return _internal_has_audio();
}
inline void FileFacet::clear_audio() {
  if (GetArenaForAllocation() == nullptr && audio_ != nullptr) {
    delete audio_;
  }
  audio_ = nullptr;
}
inline const ::grpc_services::storage::AudioFacet& FileFacet::_internal_audio() const {
  const ::grpc_services::storage::AudioFacet* p = audio_;
  return p != nullptr ? *p : reinterpret_cast<const ::grpc_services::storage::AudioFacet&>(
      ::grpc_services::storage::_AudioFacet_default_instance_);
}
inline const ::grpc_services::storage::AudioFacet& FileFacet::audio() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.FileFacet.audio)
  return _internal_audio();
}
inline void FileFacet::unsafe_arena_set_allocated_audio(
    ::grpc_services::storage::AudioFacet* audio) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(audio_);
  }
  audio_ = audio;
  if (audio) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc_services.storage.FileFacet.audio)
}
inline ::grpc_services::storage::AudioFacet* FileFacet::release_audio() {
  
  ::grpc_services::storage::AudioFacet* temp = audio_;
  audio_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::grpc_services::storage::AudioFacet* FileFacet::unsafe_arena_release_audio() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.FileFacet.audio)
  
  ::grpc_services::storage::AudioFacet* temp = audio_;
  audio_ = nullptr;
  return temp;
}
inline ::grpc_services::storage::AudioFacet* FileFacet::_internal_mutable_audio() {
  
  if (audio_ == nullptr) {
    auto* p = CreateMaybeMessage<::grpc_services::storage::AudioFacet>(GetArenaForAllocation());
    audio_ = p;
  }
  return audio_;
}
inline ::grpc_services::storage::AudioFacet* FileFacet::mutable_audio() {
  ::grpc_services::storage::AudioFacet* _msg = _internal_mutable_audio();
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.FileFacet.audio)
  return _msg;
}
inline void FileFacet::set_allocated_audio(::grpc_services::storage::AudioFacet* audio) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete audio_;
  }
  if (audio) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::grpc_services::storage::AudioFacet>::GetOwningArena(audio);
    if (message_arena != submessage_arena) {
      audio = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio, submessage_arena);
    }
    
  } else {
    
  }
  audio_ = audio;
  // @@protoc_insertion_point(field_set_allocated:grpc_services.storage.FileFacet.audio)
}

// uint64 size = 4;
inline void FileFacet::clear_size() {
  size_ = uint64_t{0u};
}
inline uint64_t FileFacet::_internal_size() const {
  return size_;
}
inline uint64_t FileFacet::size() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.FileFacet.size)
  return _internal_size();
}
inline void FileFacet::_internal_set_size(uint64_t value) {
  
  size_ = value;
}
inline void FileFacet::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:grpc_services.storage.FileFacet.size)
}

// -------------------------------------------------------------------

// AudioFacet

// uint64 bitrate = 1;
inline void AudioFacet::clear_bitrate() {
  bitrate_ = uint64_t{0u};
}
inline uint64_t AudioFacet::_internal_bitrate() const {
  return bitrate_;
}
inline uint64_t AudioFacet::bitrate() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.AudioFacet.bitrate)
  return _internal_bitrate();
}
inline void AudioFacet::_internal_set_bitrate(uint64_t value) {
  
  bitrate_ = value;
}
inline void AudioFacet::set_bitrate(uint64_t value) {
  _internal_set_bitrate(value);
  // @@protoc_insertion_point(field_set:grpc_services.storage.AudioFacet.bitrate)
}

// uint64 duration = 2;
inline void AudioFacet::clear_duration() {
  duration_ = uint64_t{0u};
}
inline uint64_t AudioFacet::_internal_duration() const {
  return duration_;
}
inline uint64_t AudioFacet::duration() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.AudioFacet.duration)
  return _internal_duration();
}
inline void AudioFacet::_internal_set_duration(uint64_t value) {
  
  duration_ = value;
}
inline void AudioFacet::set_duration(uint64_t value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:grpc_services.storage.AudioFacet.duration)
}

// bool is_vbr = 3;
inline void AudioFacet::clear_is_vbr() {
  is_vbr_ = false;
}
inline bool AudioFacet::_internal_is_vbr() const {
  return is_vbr_;
}
inline bool AudioFacet::is_vbr() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.AudioFacet.is_vbr)
  return _internal_is_vbr();
}
inline void AudioFacet::_internal_set_is_vbr(bool value) {
  
  is_vbr_ = value;
}
inline void AudioFacet::set_is_vbr(bool value) {
  _internal_set_is_vbr(value);
  // @@protoc_insertion_point(field_set:grpc_services.storage.AudioFacet.is_vbr)
}

// -------------------------------------------------------------------

// Drive

// string id = 1;
inline void Drive::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Drive::id() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.Drive.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Drive::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc_services.storage.Drive.id)
}
inline std::string* Drive::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.Drive.id)
  return _s;
}
inline const std::string& Drive::_internal_id() const {
  return id_.Get();
}
inline void Drive::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Drive::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Drive::release_id() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.Drive.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Drive::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc_services.storage.Drive.id)
}

// string name = 2;
inline void Drive::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Drive::name() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.Drive.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Drive::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc_services.storage.Drive.name)
}
inline std::string* Drive::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.Drive.name)
  return _s;
}
inline const std::string& Drive::_internal_name() const {
  return name_.Get();
}
inline void Drive::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Drive::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Drive::release_name() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.Drive.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Drive::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc_services.storage.Drive.name)
}

// string description = 3;
inline void Drive::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& Drive::description() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.Drive.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Drive::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc_services.storage.Drive.description)
}
inline std::string* Drive::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.Drive.description)
  return _s;
}
inline const std::string& Drive::_internal_description() const {
  return description_.Get();
}
inline void Drive::_internal_set_description(const std::string& value) {
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Drive::_internal_mutable_description() {
  
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Drive::release_description() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.Drive.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Drive::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc_services.storage.Drive.description)
}

// .grpc_services.common.Timestamp created_time = 4;
inline bool Drive::_internal_has_created_time() const {
  return this != internal_default_instance() && created_time_ != nullptr;
}
inline bool Drive::has_created_time() const {
  return _internal_has_created_time();
}
inline const ::grpc_services::common::Timestamp& Drive::_internal_created_time() const {
  const ::grpc_services::common::Timestamp* p = created_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::grpc_services::common::Timestamp&>(
      ::grpc_services::common::_Timestamp_default_instance_);
}
inline const ::grpc_services::common::Timestamp& Drive::created_time() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.Drive.created_time)
  return _internal_created_time();
}
inline void Drive::unsafe_arena_set_allocated_created_time(
    ::grpc_services::common::Timestamp* created_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_time_);
  }
  created_time_ = created_time;
  if (created_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc_services.storage.Drive.created_time)
}
inline ::grpc_services::common::Timestamp* Drive::release_created_time() {
  
  ::grpc_services::common::Timestamp* temp = created_time_;
  created_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::grpc_services::common::Timestamp* Drive::unsafe_arena_release_created_time() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.Drive.created_time)
  
  ::grpc_services::common::Timestamp* temp = created_time_;
  created_time_ = nullptr;
  return temp;
}
inline ::grpc_services::common::Timestamp* Drive::_internal_mutable_created_time() {
  
  if (created_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::grpc_services::common::Timestamp>(GetArenaForAllocation());
    created_time_ = p;
  }
  return created_time_;
}
inline ::grpc_services::common::Timestamp* Drive::mutable_created_time() {
  ::grpc_services::common::Timestamp* _msg = _internal_mutable_created_time();
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.Drive.created_time)
  return _msg;
}
inline void Drive::set_allocated_created_time(::grpc_services::common::Timestamp* created_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_time_);
  }
  if (created_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_time));
    if (message_arena != submessage_arena) {
      created_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_time, submessage_arena);
    }
    
  } else {
    
  }
  created_time_ = created_time;
  // @@protoc_insertion_point(field_set_allocated:grpc_services.storage.Drive.created_time)
}

// .grpc_services.common.Timestamp last_modified = 5;
inline bool Drive::_internal_has_last_modified() const {
  return this != internal_default_instance() && last_modified_ != nullptr;
}
inline bool Drive::has_last_modified() const {
  return _internal_has_last_modified();
}
inline const ::grpc_services::common::Timestamp& Drive::_internal_last_modified() const {
  const ::grpc_services::common::Timestamp* p = last_modified_;
  return p != nullptr ? *p : reinterpret_cast<const ::grpc_services::common::Timestamp&>(
      ::grpc_services::common::_Timestamp_default_instance_);
}
inline const ::grpc_services::common::Timestamp& Drive::last_modified() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.Drive.last_modified)
  return _internal_last_modified();
}
inline void Drive::unsafe_arena_set_allocated_last_modified(
    ::grpc_services::common::Timestamp* last_modified) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_modified_);
  }
  last_modified_ = last_modified;
  if (last_modified) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc_services.storage.Drive.last_modified)
}
inline ::grpc_services::common::Timestamp* Drive::release_last_modified() {
  
  ::grpc_services::common::Timestamp* temp = last_modified_;
  last_modified_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::grpc_services::common::Timestamp* Drive::unsafe_arena_release_last_modified() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.Drive.last_modified)
  
  ::grpc_services::common::Timestamp* temp = last_modified_;
  last_modified_ = nullptr;
  return temp;
}
inline ::grpc_services::common::Timestamp* Drive::_internal_mutable_last_modified() {
  
  if (last_modified_ == nullptr) {
    auto* p = CreateMaybeMessage<::grpc_services::common::Timestamp>(GetArenaForAllocation());
    last_modified_ = p;
  }
  return last_modified_;
}
inline ::grpc_services::common::Timestamp* Drive::mutable_last_modified() {
  ::grpc_services::common::Timestamp* _msg = _internal_mutable_last_modified();
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.Drive.last_modified)
  return _msg;
}
inline void Drive::set_allocated_last_modified(::grpc_services::common::Timestamp* last_modified) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_modified_);
  }
  if (last_modified) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_modified));
    if (message_arena != submessage_arena) {
      last_modified = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_modified, submessage_arena);
    }
    
  } else {
    
  }
  last_modified_ = last_modified;
  // @@protoc_insertion_point(field_set_allocated:grpc_services.storage.Drive.last_modified)
}

// .grpc_services.common.Timestamp last_item_modified = 6;
inline bool Drive::_internal_has_last_item_modified() const {
  return this != internal_default_instance() && last_item_modified_ != nullptr;
}
inline bool Drive::has_last_item_modified() const {
  return _internal_has_last_item_modified();
}
inline const ::grpc_services::common::Timestamp& Drive::_internal_last_item_modified() const {
  const ::grpc_services::common::Timestamp* p = last_item_modified_;
  return p != nullptr ? *p : reinterpret_cast<const ::grpc_services::common::Timestamp&>(
      ::grpc_services::common::_Timestamp_default_instance_);
}
inline const ::grpc_services::common::Timestamp& Drive::last_item_modified() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.Drive.last_item_modified)
  return _internal_last_item_modified();
}
inline void Drive::unsafe_arena_set_allocated_last_item_modified(
    ::grpc_services::common::Timestamp* last_item_modified) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_item_modified_);
  }
  last_item_modified_ = last_item_modified;
  if (last_item_modified) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc_services.storage.Drive.last_item_modified)
}
inline ::grpc_services::common::Timestamp* Drive::release_last_item_modified() {
  
  ::grpc_services::common::Timestamp* temp = last_item_modified_;
  last_item_modified_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::grpc_services::common::Timestamp* Drive::unsafe_arena_release_last_item_modified() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.Drive.last_item_modified)
  
  ::grpc_services::common::Timestamp* temp = last_item_modified_;
  last_item_modified_ = nullptr;
  return temp;
}
inline ::grpc_services::common::Timestamp* Drive::_internal_mutable_last_item_modified() {
  
  if (last_item_modified_ == nullptr) {
    auto* p = CreateMaybeMessage<::grpc_services::common::Timestamp>(GetArenaForAllocation());
    last_item_modified_ = p;
  }
  return last_item_modified_;
}
inline ::grpc_services::common::Timestamp* Drive::mutable_last_item_modified() {
  ::grpc_services::common::Timestamp* _msg = _internal_mutable_last_item_modified();
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.Drive.last_item_modified)
  return _msg;
}
inline void Drive::set_allocated_last_item_modified(::grpc_services::common::Timestamp* last_item_modified) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_item_modified_);
  }
  if (last_item_modified) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_item_modified));
    if (message_arena != submessage_arena) {
      last_item_modified = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_item_modified, submessage_arena);
    }
    
  } else {
    
  }
  last_item_modified_ = last_item_modified;
  // @@protoc_insertion_point(field_set_allocated:grpc_services.storage.Drive.last_item_modified)
}

// -------------------------------------------------------------------

// Item

// string id = 1;
inline void Item::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Item::id() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.Item.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Item::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc_services.storage.Item.id)
}
inline std::string* Item::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.Item.id)
  return _s;
}
inline const std::string& Item::_internal_id() const {
  return id_.Get();
}
inline void Item::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Item::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Item::release_id() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.Item.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Item::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc_services.storage.Item.id)
}

// string name = 2;
inline void Item::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Item::name() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.Item.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Item::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc_services.storage.Item.name)
}
inline std::string* Item::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.Item.name)
  return _s;
}
inline const std::string& Item::_internal_name() const {
  return name_.Get();
}
inline void Item::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Item::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Item::release_name() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.Item.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Item::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc_services.storage.Item.name)
}

// string description = 3;
inline void Item::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& Item::description() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.Item.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Item::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc_services.storage.Item.description)
}
inline std::string* Item::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.Item.description)
  return _s;
}
inline const std::string& Item::_internal_description() const {
  return description_.Get();
}
inline void Item::_internal_set_description(const std::string& value) {
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Item::_internal_mutable_description() {
  
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Item::release_description() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.Item.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Item::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc_services.storage.Item.description)
}

// .grpc_services.common.Timestamp created_time = 4;
inline bool Item::_internal_has_created_time() const {
  return this != internal_default_instance() && created_time_ != nullptr;
}
inline bool Item::has_created_time() const {
  return _internal_has_created_time();
}
inline const ::grpc_services::common::Timestamp& Item::_internal_created_time() const {
  const ::grpc_services::common::Timestamp* p = created_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::grpc_services::common::Timestamp&>(
      ::grpc_services::common::_Timestamp_default_instance_);
}
inline const ::grpc_services::common::Timestamp& Item::created_time() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.Item.created_time)
  return _internal_created_time();
}
inline void Item::unsafe_arena_set_allocated_created_time(
    ::grpc_services::common::Timestamp* created_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_time_);
  }
  created_time_ = created_time;
  if (created_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc_services.storage.Item.created_time)
}
inline ::grpc_services::common::Timestamp* Item::release_created_time() {
  
  ::grpc_services::common::Timestamp* temp = created_time_;
  created_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::grpc_services::common::Timestamp* Item::unsafe_arena_release_created_time() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.Item.created_time)
  
  ::grpc_services::common::Timestamp* temp = created_time_;
  created_time_ = nullptr;
  return temp;
}
inline ::grpc_services::common::Timestamp* Item::_internal_mutable_created_time() {
  
  if (created_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::grpc_services::common::Timestamp>(GetArenaForAllocation());
    created_time_ = p;
  }
  return created_time_;
}
inline ::grpc_services::common::Timestamp* Item::mutable_created_time() {
  ::grpc_services::common::Timestamp* _msg = _internal_mutable_created_time();
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.Item.created_time)
  return _msg;
}
inline void Item::set_allocated_created_time(::grpc_services::common::Timestamp* created_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_time_);
  }
  if (created_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_time));
    if (message_arena != submessage_arena) {
      created_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_time, submessage_arena);
    }
    
  } else {
    
  }
  created_time_ = created_time;
  // @@protoc_insertion_point(field_set_allocated:grpc_services.storage.Item.created_time)
}

// .grpc_services.common.Timestamp last_modified = 5;
inline bool Item::_internal_has_last_modified() const {
  return this != internal_default_instance() && last_modified_ != nullptr;
}
inline bool Item::has_last_modified() const {
  return _internal_has_last_modified();
}
inline const ::grpc_services::common::Timestamp& Item::_internal_last_modified() const {
  const ::grpc_services::common::Timestamp* p = last_modified_;
  return p != nullptr ? *p : reinterpret_cast<const ::grpc_services::common::Timestamp&>(
      ::grpc_services::common::_Timestamp_default_instance_);
}
inline const ::grpc_services::common::Timestamp& Item::last_modified() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.Item.last_modified)
  return _internal_last_modified();
}
inline void Item::unsafe_arena_set_allocated_last_modified(
    ::grpc_services::common::Timestamp* last_modified) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_modified_);
  }
  last_modified_ = last_modified;
  if (last_modified) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc_services.storage.Item.last_modified)
}
inline ::grpc_services::common::Timestamp* Item::release_last_modified() {
  
  ::grpc_services::common::Timestamp* temp = last_modified_;
  last_modified_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::grpc_services::common::Timestamp* Item::unsafe_arena_release_last_modified() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.Item.last_modified)
  
  ::grpc_services::common::Timestamp* temp = last_modified_;
  last_modified_ = nullptr;
  return temp;
}
inline ::grpc_services::common::Timestamp* Item::_internal_mutable_last_modified() {
  
  if (last_modified_ == nullptr) {
    auto* p = CreateMaybeMessage<::grpc_services::common::Timestamp>(GetArenaForAllocation());
    last_modified_ = p;
  }
  return last_modified_;
}
inline ::grpc_services::common::Timestamp* Item::mutable_last_modified() {
  ::grpc_services::common::Timestamp* _msg = _internal_mutable_last_modified();
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.Item.last_modified)
  return _msg;
}
inline void Item::set_allocated_last_modified(::grpc_services::common::Timestamp* last_modified) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_modified_);
  }
  if (last_modified) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_modified));
    if (message_arena != submessage_arena) {
      last_modified = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_modified, submessage_arena);
    }
    
  } else {
    
  }
  last_modified_ = last_modified;
  // @@protoc_insertion_point(field_set_allocated:grpc_services.storage.Item.last_modified)
}

// string parent_id = 6;
inline void Item::clear_parent_id() {
  parent_id_.ClearToEmpty();
}
inline const std::string& Item::parent_id() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.Item.parent_id)
  return _internal_parent_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Item::set_parent_id(ArgT0&& arg0, ArgT... args) {
 
 parent_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc_services.storage.Item.parent_id)
}
inline std::string* Item::mutable_parent_id() {
  std::string* _s = _internal_mutable_parent_id();
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.Item.parent_id)
  return _s;
}
inline const std::string& Item::_internal_parent_id() const {
  return parent_id_.Get();
}
inline void Item::_internal_set_parent_id(const std::string& value) {
  
  parent_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Item::_internal_mutable_parent_id() {
  
  return parent_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Item::release_parent_id() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.Item.parent_id)
  return parent_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Item::set_allocated_parent_id(std::string* parent_id) {
  if (parent_id != nullptr) {
    
  } else {
    
  }
  parent_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), parent_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (parent_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    parent_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc_services.storage.Item.parent_id)
}

// .grpc_services.storage.ItemType type = 7;
inline void Item::clear_type() {
  type_ = 0;
}
inline ::grpc_services::storage::ItemType Item::_internal_type() const {
  return static_cast< ::grpc_services::storage::ItemType >(type_);
}
inline ::grpc_services::storage::ItemType Item::type() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.Item.type)
  return _internal_type();
}
inline void Item::_internal_set_type(::grpc_services::storage::ItemType value) {
  
  type_ = value;
}
inline void Item::set_type(::grpc_services::storage::ItemType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:grpc_services.storage.Item.type)
}

// .grpc_services.storage.FileFacet file = 8;
inline bool Item::_internal_has_file() const {
  return test_type_case() == kFile;
}
inline bool Item::has_file() const {
  return _internal_has_file();
}
inline void Item::set_has_file() {
  _oneof_case_[0] = kFile;
}
inline void Item::clear_file() {
  if (_internal_has_file()) {
    if (GetArenaForAllocation() == nullptr) {
      delete test_type_.file_;
    }
    clear_has_test_type();
  }
}
inline ::grpc_services::storage::FileFacet* Item::release_file() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.Item.file)
  if (_internal_has_file()) {
    clear_has_test_type();
      ::grpc_services::storage::FileFacet* temp = test_type_.file_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    test_type_.file_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc_services::storage::FileFacet& Item::_internal_file() const {
  return _internal_has_file()
      ? *test_type_.file_
      : reinterpret_cast< ::grpc_services::storage::FileFacet&>(::grpc_services::storage::_FileFacet_default_instance_);
}
inline const ::grpc_services::storage::FileFacet& Item::file() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.Item.file)
  return _internal_file();
}
inline ::grpc_services::storage::FileFacet* Item::unsafe_arena_release_file() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc_services.storage.Item.file)
  if (_internal_has_file()) {
    clear_has_test_type();
    ::grpc_services::storage::FileFacet* temp = test_type_.file_;
    test_type_.file_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Item::unsafe_arena_set_allocated_file(::grpc_services::storage::FileFacet* file) {
  clear_test_type();
  if (file) {
    set_has_file();
    test_type_.file_ = file;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc_services.storage.Item.file)
}
inline ::grpc_services::storage::FileFacet* Item::_internal_mutable_file() {
  if (!_internal_has_file()) {
    clear_test_type();
    set_has_file();
    test_type_.file_ = CreateMaybeMessage< ::grpc_services::storage::FileFacet >(GetArenaForAllocation());
  }
  return test_type_.file_;
}
inline ::grpc_services::storage::FileFacet* Item::mutable_file() {
  ::grpc_services::storage::FileFacet* _msg = _internal_mutable_file();
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.Item.file)
  return _msg;
}

// .grpc_services.storage.FolderFacet folder = 9;
inline bool Item::_internal_has_folder() const {
  return test_type_case() == kFolder;
}
inline bool Item::has_folder() const {
  return _internal_has_folder();
}
inline void Item::set_has_folder() {
  _oneof_case_[0] = kFolder;
}
inline void Item::clear_folder() {
  if (_internal_has_folder()) {
    if (GetArenaForAllocation() == nullptr) {
      delete test_type_.folder_;
    }
    clear_has_test_type();
  }
}
inline ::grpc_services::storage::FolderFacet* Item::release_folder() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.Item.folder)
  if (_internal_has_folder()) {
    clear_has_test_type();
      ::grpc_services::storage::FolderFacet* temp = test_type_.folder_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    test_type_.folder_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc_services::storage::FolderFacet& Item::_internal_folder() const {
  return _internal_has_folder()
      ? *test_type_.folder_
      : reinterpret_cast< ::grpc_services::storage::FolderFacet&>(::grpc_services::storage::_FolderFacet_default_instance_);
}
inline const ::grpc_services::storage::FolderFacet& Item::folder() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.Item.folder)
  return _internal_folder();
}
inline ::grpc_services::storage::FolderFacet* Item::unsafe_arena_release_folder() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc_services.storage.Item.folder)
  if (_internal_has_folder()) {
    clear_has_test_type();
    ::grpc_services::storage::FolderFacet* temp = test_type_.folder_;
    test_type_.folder_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Item::unsafe_arena_set_allocated_folder(::grpc_services::storage::FolderFacet* folder) {
  clear_test_type();
  if (folder) {
    set_has_folder();
    test_type_.folder_ = folder;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc_services.storage.Item.folder)
}
inline ::grpc_services::storage::FolderFacet* Item::_internal_mutable_folder() {
  if (!_internal_has_folder()) {
    clear_test_type();
    set_has_folder();
    test_type_.folder_ = CreateMaybeMessage< ::grpc_services::storage::FolderFacet >(GetArenaForAllocation());
  }
  return test_type_.folder_;
}
inline ::grpc_services::storage::FolderFacet* Item::mutable_folder() {
  ::grpc_services::storage::FolderFacet* _msg = _internal_mutable_folder();
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.Item.folder)
  return _msg;
}

inline bool Item::has_test_type() const {
  return test_type_case() != TEST_TYPE_NOT_SET;
}
inline void Item::clear_has_test_type() {
  _oneof_case_[0] = TEST_TYPE_NOT_SET;
}
inline Item::TestTypeCase Item::test_type_case() const {
  return Item::TestTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ItemCreatedEvent

// .grpc_services.storage.Item item = 1;
inline bool ItemCreatedEvent::_internal_has_item() const {
  return this != internal_default_instance() && item_ != nullptr;
}
inline bool ItemCreatedEvent::has_item() const {
  return _internal_has_item();
}
inline void ItemCreatedEvent::clear_item() {
  if (GetArenaForAllocation() == nullptr && item_ != nullptr) {
    delete item_;
  }
  item_ = nullptr;
}
inline const ::grpc_services::storage::Item& ItemCreatedEvent::_internal_item() const {
  const ::grpc_services::storage::Item* p = item_;
  return p != nullptr ? *p : reinterpret_cast<const ::grpc_services::storage::Item&>(
      ::grpc_services::storage::_Item_default_instance_);
}
inline const ::grpc_services::storage::Item& ItemCreatedEvent::item() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.ItemCreatedEvent.item)
  return _internal_item();
}
inline void ItemCreatedEvent::unsafe_arena_set_allocated_item(
    ::grpc_services::storage::Item* item) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(item_);
  }
  item_ = item;
  if (item) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc_services.storage.ItemCreatedEvent.item)
}
inline ::grpc_services::storage::Item* ItemCreatedEvent::release_item() {
  
  ::grpc_services::storage::Item* temp = item_;
  item_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::grpc_services::storage::Item* ItemCreatedEvent::unsafe_arena_release_item() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.ItemCreatedEvent.item)
  
  ::grpc_services::storage::Item* temp = item_;
  item_ = nullptr;
  return temp;
}
inline ::grpc_services::storage::Item* ItemCreatedEvent::_internal_mutable_item() {
  
  if (item_ == nullptr) {
    auto* p = CreateMaybeMessage<::grpc_services::storage::Item>(GetArenaForAllocation());
    item_ = p;
  }
  return item_;
}
inline ::grpc_services::storage::Item* ItemCreatedEvent::mutable_item() {
  ::grpc_services::storage::Item* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.ItemCreatedEvent.item)
  return _msg;
}
inline void ItemCreatedEvent::set_allocated_item(::grpc_services::storage::Item* item) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete item_;
  }
  if (item) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::grpc_services::storage::Item>::GetOwningArena(item);
    if (message_arena != submessage_arena) {
      item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item, submessage_arena);
    }
    
  } else {
    
  }
  item_ = item;
  // @@protoc_insertion_point(field_set_allocated:grpc_services.storage.ItemCreatedEvent.item)
}

// -------------------------------------------------------------------

// ItemRemovedEvent

// .grpc_services.storage.Item item = 1;
inline bool ItemRemovedEvent::_internal_has_item() const {
  return this != internal_default_instance() && item_ != nullptr;
}
inline bool ItemRemovedEvent::has_item() const {
  return _internal_has_item();
}
inline void ItemRemovedEvent::clear_item() {
  if (GetArenaForAllocation() == nullptr && item_ != nullptr) {
    delete item_;
  }
  item_ = nullptr;
}
inline const ::grpc_services::storage::Item& ItemRemovedEvent::_internal_item() const {
  const ::grpc_services::storage::Item* p = item_;
  return p != nullptr ? *p : reinterpret_cast<const ::grpc_services::storage::Item&>(
      ::grpc_services::storage::_Item_default_instance_);
}
inline const ::grpc_services::storage::Item& ItemRemovedEvent::item() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.ItemRemovedEvent.item)
  return _internal_item();
}
inline void ItemRemovedEvent::unsafe_arena_set_allocated_item(
    ::grpc_services::storage::Item* item) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(item_);
  }
  item_ = item;
  if (item) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc_services.storage.ItemRemovedEvent.item)
}
inline ::grpc_services::storage::Item* ItemRemovedEvent::release_item() {
  
  ::grpc_services::storage::Item* temp = item_;
  item_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::grpc_services::storage::Item* ItemRemovedEvent::unsafe_arena_release_item() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.ItemRemovedEvent.item)
  
  ::grpc_services::storage::Item* temp = item_;
  item_ = nullptr;
  return temp;
}
inline ::grpc_services::storage::Item* ItemRemovedEvent::_internal_mutable_item() {
  
  if (item_ == nullptr) {
    auto* p = CreateMaybeMessage<::grpc_services::storage::Item>(GetArenaForAllocation());
    item_ = p;
  }
  return item_;
}
inline ::grpc_services::storage::Item* ItemRemovedEvent::mutable_item() {
  ::grpc_services::storage::Item* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.ItemRemovedEvent.item)
  return _msg;
}
inline void ItemRemovedEvent::set_allocated_item(::grpc_services::storage::Item* item) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete item_;
  }
  if (item) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::grpc_services::storage::Item>::GetOwningArena(item);
    if (message_arena != submessage_arena) {
      item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item, submessage_arena);
    }
    
  } else {
    
  }
  item_ = item;
  // @@protoc_insertion_point(field_set_allocated:grpc_services.storage.ItemRemovedEvent.item)
}

// -------------------------------------------------------------------

// ItemContentUpdatedEvent

// .grpc_services.storage.Item item = 1;
inline bool ItemContentUpdatedEvent::_internal_has_item() const {
  return this != internal_default_instance() && item_ != nullptr;
}
inline bool ItemContentUpdatedEvent::has_item() const {
  return _internal_has_item();
}
inline void ItemContentUpdatedEvent::clear_item() {
  if (GetArenaForAllocation() == nullptr && item_ != nullptr) {
    delete item_;
  }
  item_ = nullptr;
}
inline const ::grpc_services::storage::Item& ItemContentUpdatedEvent::_internal_item() const {
  const ::grpc_services::storage::Item* p = item_;
  return p != nullptr ? *p : reinterpret_cast<const ::grpc_services::storage::Item&>(
      ::grpc_services::storage::_Item_default_instance_);
}
inline const ::grpc_services::storage::Item& ItemContentUpdatedEvent::item() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.ItemContentUpdatedEvent.item)
  return _internal_item();
}
inline void ItemContentUpdatedEvent::unsafe_arena_set_allocated_item(
    ::grpc_services::storage::Item* item) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(item_);
  }
  item_ = item;
  if (item) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc_services.storage.ItemContentUpdatedEvent.item)
}
inline ::grpc_services::storage::Item* ItemContentUpdatedEvent::release_item() {
  
  ::grpc_services::storage::Item* temp = item_;
  item_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::grpc_services::storage::Item* ItemContentUpdatedEvent::unsafe_arena_release_item() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.ItemContentUpdatedEvent.item)
  
  ::grpc_services::storage::Item* temp = item_;
  item_ = nullptr;
  return temp;
}
inline ::grpc_services::storage::Item* ItemContentUpdatedEvent::_internal_mutable_item() {
  
  if (item_ == nullptr) {
    auto* p = CreateMaybeMessage<::grpc_services::storage::Item>(GetArenaForAllocation());
    item_ = p;
  }
  return item_;
}
inline ::grpc_services::storage::Item* ItemContentUpdatedEvent::mutable_item() {
  ::grpc_services::storage::Item* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.ItemContentUpdatedEvent.item)
  return _msg;
}
inline void ItemContentUpdatedEvent::set_allocated_item(::grpc_services::storage::Item* item) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete item_;
  }
  if (item) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::grpc_services::storage::Item>::GetOwningArena(item);
    if (message_arena != submessage_arena) {
      item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item, submessage_arena);
    }
    
  } else {
    
  }
  item_ = item;
  // @@protoc_insertion_point(field_set_allocated:grpc_services.storage.ItemContentUpdatedEvent.item)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace storage
}  // namespace grpc_services

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::grpc_services::storage::ItemType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::grpc_services::storage::ItemType>() {
  return ::grpc_services::storage::ItemType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_grpc_5fservices_2fstorage_2fentities_2eproto
